<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Zining Qi" />


<title>Replication analysis for xQTL</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<link rel="icon" href="https://github.com/workflowr/workflowr-assets/raw/main/img/reproducible.png">
<!-- Add a small amount of space between sections. -->
<style type="text/css">
div.section {
  padding-top: 12px;
}
</style>



<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Missing Data Imputation for Multi-Omics Data</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Overview</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/zq2209/omics-imputation-paper">source</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Replication analysis for xQTL</h1>
<h4 class="author">Zining Qi</h4>

</div>


<p>
<button type="button" class="btn btn-default btn-workflowr btn-workflowr-report" data-toggle="collapse" data-target="#workflowr-report">
<span class="glyphicon glyphicon-list" aria-hidden="true"></span>
workflowr <span class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span>
</button>
</p>
<div id="workflowr-report" class="collapse">
<ul class="nav nav-tabs">
<li class="active">
<a data-toggle="tab" href="#summary">Summary</a>
</li>
<li>
<a data-toggle="tab" href="#checks"> Checks <span
class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span> </a>
</li>
<li>
<a data-toggle="tab" href="#versions">Past versions</a>
</li>
</ul>
<div class="tab-content">
<div id="summary" class="tab-pane fade in active">
<p>
<strong>Last updated:</strong> 2025-04-13
</p>
<p>
<strong>Checks:</strong> <span
class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> 6
<span class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span> 1
</p>
<p>
<strong>Knit directory:</strong>
<code>omics-imputation-paper/analysis/</code> <span
class="glyphicon glyphicon-question-sign" aria-hidden="true"
title="This is the local directory in which the code in this file was executed.">
</span>
</p>
<p>
This reproducible <a href="https://rmarkdown.rstudio.com">R Markdown</a>
analysis was created with <a
  href="https://github.com/workflowr/workflowr">workflowr</a> (version
1.7.1). The <em>Checks</em> tab describes the reproducibility checks
that were applied when the results were created. The <em>Past
versions</em> tab lists the development history.
</p>
<hr>
</div>
<div id="checks" class="tab-pane fade">
<div id="workflowr-checks" class="panel-group">
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongRMarkdownfilestronguncommittedchanges">
<span class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span> <strong>R Markdown file:</strong> uncommitted
changes </a>
</p>
</div>
<div id="strongRMarkdownfilestronguncommittedchanges"
class="panel-collapse collapse">
<div class="panel-body">
<p>The R Markdown file has unstaged changes. To know which version of
the R Markdown file created these results, you’ll want to first commit
it to the Git repo. If you’re still working on the analysis, you can
ignore this warning. When you’re finished, you can run
<code>wflow_publish</code> to commit the R Markdown file and build the
HTML.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongEnvironmentstrongempty">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Environment:</strong> empty </a>
</p>
</div>
<div id="strongEnvironmentstrongempty" class="panel-collapse collapse">
<div class="panel-body">
<p>Great job! The global environment was empty. Objects defined in the
global environment can affect the analysis in your R Markdown file in
unknown ways. For reproduciblity it’s best to always run the code in an
empty environment.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongSeedstrongcodesetseed1code">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Seed:</strong>
<code>set.seed(1)</code> </a>
</p>
</div>
<div id="strongSeedstrongcodesetseed1code"
class="panel-collapse collapse">
<div class="panel-body">
<p>The command <code>set.seed(1)</code> was run prior to running the
code in the R Markdown file. Setting a seed ensures that any results
that rely on randomness, e.g. subsampling or permutations, are
reproducible.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongSessioninformationstrongrecorded">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Session information:</strong>
recorded </a>
</p>
</div>
<div id="strongSessioninformationstrongrecorded"
class="panel-collapse collapse">
<div class="panel-body">
<p>Great job! Recording the operating system, R version, and package
versions is critical for reproducibility.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongCachestrongnone">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Cache:</strong> none </a>
</p>
</div>
<div id="strongCachestrongnone" class="panel-collapse collapse">
<div class="panel-body">
<p>Nice! There were no cached chunks for this analysis, so you can be
confident that you successfully produced the results during this
run.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongFilepathsstrongrelative">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>File paths:</strong> relative </a>
</p>
</div>
<div id="strongFilepathsstrongrelative" class="panel-collapse collapse">
<div class="panel-body">
<p>Great job! Using relative paths to the files within your workflowr
project makes it easier to run your code on other machines.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongRepositoryversionstrongahrefhttpsgithubcomzq2209omicsimputationpapertreee3d5ff594ec35639bbde95fc6e7248607a730301targetblanke3d5ff5a">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Repository version:</strong>
<a href="https://github.com/zq2209/omics-imputation-paper/tree/e3d5ff594ec35639bbde95fc6e7248607a730301" target="_blank">e3d5ff5</a>
</a>
</p>
</div>
<div
id="strongRepositoryversionstrongahrefhttpsgithubcomzq2209omicsimputationpapertreee3d5ff594ec35639bbde95fc6e7248607a730301targetblanke3d5ff5a"
class="panel-collapse collapse">
<div class="panel-body">
<p>
Great! You are using Git for version control. Tracking code development
and connecting the code version to the results is critical for
reproducibility.
</p>
<p>
The results in this page were generated with repository version
<a href="https://github.com/zq2209/omics-imputation-paper/tree/e3d5ff594ec35639bbde95fc6e7248607a730301" target="_blank">e3d5ff5</a>.
See the <em>Past versions</em> tab to see a history of the changes made
to the R Markdown and HTML files.
</p>
<p>
Note that you need to be careful to ensure that all relevant files for
the analysis have been committed to Git prior to generating the results
(you can use <code>wflow_publish</code> or
<code>wflow_git_commit</code>). workflowr only checks the R Markdown
file, but you know if there are other scripts or data files that it
depends on. Below is the status of the Git repository when the results
were generated:
</p>
<pre><code>
Ignored files:
    Ignored:    .Rproj.user/

Unstaged changes:
    Modified:   analysis/xqtl_replication.Rmd

</code></pre>
<p>
Note that any generated files, e.g. HTML, png, CSS, etc., are not
included in this status report because it is ok for generated content to
have uncommitted changes.
</p>
</div>
</div>
</div>
</div>
<hr>
</div>
<div id="versions" class="tab-pane fade">
<p>
These are the previous versions of the repository in which changes were
made to the R Markdown (<code>analysis/xqtl_replication.Rmd</code>) and
HTML (<code>docs/xqtl_replication.html</code>) files. If you’ve
configured a remote Git repository (see <code>?wflow_git_remote</code>),
click on the hyperlinks in the table below to view the files as they
were in that past version.
</p>
<div class="table-responsive">
<table class="table table-condensed table-hover">
<thead>
<tr>
<th>
File
</th>
<th>
Version
</th>
<th>
Author
</th>
<th>
Date
</th>
<th>
Message
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Rmd
</td>
<td>
<a href="https://github.com/zq2209/omics-imputation-paper/blob/e3d5ff594ec35639bbde95fc6e7248607a730301/analysis/xqtl_replication.Rmd" target="_blank">e3d5ff5</a>
</td>
<td>
“John
</td>
<td>
2025-04-13
</td>
<td>
update
</td>
</tr>
</tbody>
</table>
</div>
<hr>
</div>
</div>
</div>
<p>In the context of real-world xQTL discoveries, the absence of known
ground truth poses a challenge in validating the robustness of different
imputation methods for the xQTL signals obtained through them. To
address this, we conduct replication analyses on proteomics data from
ROSMAP. This page documents the procedure of replication analysis.</p>
<div id="setup-and-initial-data-loading" class="section level3">
<h3>Setup and Initial Data Loading</h3>
<p>First, load the packages needed for this analysis and the original
phenotype data.</p>
<pre class="r"><code>library(tidyverse)
library(data.table)
library(qvalue)
library(stringr)
library(patchwork)

pheno &lt;- read_delim(&#39;combine_r1andr2_protein.reg_cov_cog.uniq.proj.bed.gz&#39;)</code></pre>
</div>
<div id="replication-analysis-on-strategy-a" class="section level3">
<h3>Replication Analysis on Strategy A</h3>
<div id="define-standard-set" class="section level5">
<h5>Define Standard Set</h5>
<p>We defined the standard set as the pQTL result using subset of
observed samples in proteomics data. We focus on the proteins with <span
class="math inline">\(&gt;350\)</span> observed samples. For proteins
with more than 350 observed samples, QTL analysis is conducted on
observed samples.</p>
<p>First, we split the phenotype by each features (i.e. proteins) with
more than 350 observed samples.</p>
<pre class="r"><code>write_bed &lt;- function(data_row, file_name) {
  # Write the row to a BED file
  write_delim(data_row, file_name, delim = &#39;\t&#39;)
}</code></pre>
<pre class="r"><code>gene_list &lt;- c()
id_list &lt;- c()
chr_list &lt;- c()
for (i in 1:nrow(pheno)) {
  data_row &lt;- pheno[i, ]

  # Calculate number of exsiting samples
  num &lt;- sum(!is.na(data_row[, -c(1:4)]))

  # Create file name
  file_name &lt;- paste0(&#39;strategy1/input_per_gene/standard/rosmap_pheno.&#39;, data_row$ID, &#39;.bed&#39;)
  ensg_id &lt;- str_extract(data_row$ID, &quot;ENSG[0-9]+&quot;)

  # Write the row to a BED file if there are more than 350 exsiting samples
  if (length(data_row) &gt; 350) {
    write_bed(data_row, file_name)
    gene_list &lt;- c(gene_list, ensg_id)
    id_list &lt;- c(id_list, data_row$ID)
    chr_list &lt;- c(chr_list, data_row$chr)
  }
}</code></pre>
<p>Then, we run cis-QTL analysis on each protein with more than 350
samples by using <a
href="https://github.com/StatFunGen/xqtl-protocol">FunGen-xQTL
Computational Protocol</a>.</p>
<pre class="r"><code>for (i in length(gene_lst)) {
    sos_command &lt;- paste0(
        &quot;sos run xqtl-protocol/pipeline/TensorQTL.ipynb cis:1  &quot;,
        &quot;--genotype-file ROSMAP_NIA_WGS.leftnorm.bcftools_qc.plink_qc.&quot;, gene_list[i], &quot;.bed &quot;,
        &quot;--phenotype-file strategy1/input_per_gene/standard/rosmap_pheno.&quot;, id_list[i], &quot;.bed.gz &quot;,
        &quot;--covariate-file cov/soft/rosmap_soft.resid.Marchenko_PC.gz &quot;,
        &quot;--customized_cis_windows ROSMAP_pQTL_TADB_enhanced_cis.bed &quot;,
        &quot;--cwd strategy1/output/standard &quot;,
        &quot;--container containers/tensorqtl.sif --MAC 5 --chromosome &quot;, chr_list[i],
        &quot; -s build&quot;, 
        sep = &quot; &quot;
      )

    sbatch_script &lt;- paste(
        &quot;#!/bin/bash\n&quot;,
        &quot;#SBATCH --job-name=tensor_&quot;, gene_list[i], &quot;\n&quot;,
        &quot;#SBATCH --mem=30G\n&quot;,
        &quot;#SBATCH --time=10:00:00\n&quot;,
        &quot;#SBATCH --output=output/tensor_%j.out\n&quot;,
        &quot;#SBATCH --error=output/tensor_%j.err\n&quot;,
        &quot;#SBATCH -p CSG\n\n&quot;,
        &quot;export PATH=
PATH\n&quot;,
        &quot;source ~/.bashrc\n&quot;,
        &quot;module load Singularity/3.9.4\n&quot;,
        &quot;cd ~\n\n&quot;,
        sos_command,
        sep = &quot;&quot;
    )
    
    writeLines(sbatch_script, con = file.path(&#39;strategy1/script/&#39;, paste0(&quot;tensor_&quot;, id_list[i], &quot;.sbatch&quot;)))
}</code></pre>
<p>The result from this step is considered as replication set.</p>
</div>
<div id="define-imputed-set" class="section level5">
<h5>Define Imputed Set</h5>
<p>For each of 8 imputation methods, we imputed the proteomics data
first by using each method. Refer to Section
<code>Impute Dataset with Generated Missing by Using Different Methods</code>
in <a
href="https://zq2209.github.io/omics-imputation-paper/imputation_accuracy_benchmark.html">imputation
accuracy benchmark</a> for details on how to impute missing data. The
output of imputation is
<code>rosmap_pheno_{method}_imp.bed.gz</code>.</p>
<p>And then we randomly selected subsets of samples with different
sample sizes (eg, N=200, 250, 300) for proteins to conduct QTL
analysis.</p>
<pre class="r"><code>n &lt;- 200, 250, 300
for (mtd in c(&quot;ebmf&quot;, &quot;mofa&quot;, &quot;xgb&quot;, &quot;rf&quot;, &quot;soft&quot;, &quot;knn&quot;, &quot;mean&quot;, &quot;lod&quot;)) {
  pheno &lt;- fread(paste0(&#39;rosmap_pheno_&#39;, mtd, &#39;_imp.bed.gz&#39;))
  samples &lt;- colnames(pheno)[-c(1:4)]
  
  for (i in 1:nrow(pheno)) {
    data_row &lt;- pheno[i, ]
  
    # randomly select samples
    sel_samples &lt;- c(colnames(pheno)[c(1:4)], sample(samples, n))
    data_row &lt;- pheno[i, sel_samples]
    # Create file name
    file_name &lt;- paste0(&#39;strategy1/input_per_gene/&#39;, mtd, &#39;/rosmap_pheno.&#39;, data_row$ID, &#39;.bed&#39;)
  
    # Write the row to a BED file if there are more than 350 exsiting samples
    if (data_row$ID %in% chr_list) {
      write_bed(data_row, file_name)
    }
  }
}</code></pre>
<p>Before running cis-QTL analysis for each method, we identify hidden
factors and calculate residuals first.</p>
<pre class="r"><code>for (mtd in c(&quot;ebmf&quot;, &quot;mofa&quot;, &quot;xgb&quot;, &quot;rf&quot;, &quot;soft&quot;, &quot;knn&quot;, &quot;mean&quot;, &quot;lod&quot;)) {
    hidden_sos &lt;- paste0(
        &quot;sos run xqtl-protocol/pipeline/covariate_hidden_factor.ipynb Marchenko_PC  &quot;,
        &quot;--phenoFile strategy1/rosmap_pheno.&quot;, mtd, &quot;_imp.bed.gz &quot;,
        &quot;--covFile cov/ROSMAP_cov.ROSMAP_NIA_WGS.leftnorm.bcftools_qc.plink_qc.rosmap_proteomics.unrelated.plink_qc.prune.pca.gz &quot;,
        &quot;--cwd strategy1/input_&quot;, mtd, &quot; &quot;,
        &quot;--container containers/pcatools.sif -J 50&quot;,
        sep = &quot; &quot;
    )
    
    sbatch_script &lt;- paste(
        &quot;#!/bin/bash\n&quot;,
        &quot;#SBATCH --job-name=hidden_&quot;, mtd, &quot;\n&quot;,
        &quot;#SBATCH --mem=30G\n&quot;,
        &quot;#SBATCH --time=10:00:00\n&quot;,
        &quot;#SBATCH --output=/hidden_%j.out\n&quot;,
        &quot;#SBATCH --error=/hidden_%j.err\n&quot;,
        &quot;#SBATCH -p CSG\n\n&quot;,
        &quot;export PATH=
PATH\n&quot;,
        &quot;source ~/.bashrc\n&quot;,
        &quot;module load Singularity/3.9.4\n&quot;,
        &quot;cd ~\n\n&quot;,
        hidden_sos,
        sep = &quot;&quot;
    )
    
    writeLines(sbatch_script, con = file.path(&#39;strategy1/script_imp/&#39;, paste0(&quot;hidden_&quot;, mtd, &quot;.sbatch&quot;)))
}</code></pre>
<p>Next step is to run cis-QTL analysis for each method.</p>
<pre class="r"><code>for (mtd in c(&quot;ebmf&quot;, &quot;mofa&quot;, &quot;xgb&quot;, &quot;rf&quot;, &quot;soft&quot;, &quot;knn&quot;, &quot;mean&quot;, &quot;lod&quot;)) {
    for (i in length(gene_lst)) {
        sos &lt;- paste0(
            &quot;sos run xqtl-protocol/pipeline/TensorQTL.ipynb cis:1  &quot;,
            &quot;--genotype-file ROSMAP_NIA_WGS.leftnorm.bcftools_qc.plink_qc.&quot;, gene_list[i], &quot;.bed &quot;,
            &quot;--phenotype-file strategy1/input_per_gene/&quot;, mtd, &#39;/rosmap_pheno.&#39;, data_row$ID, &quot;.bed.gz &quot;,
            &quot;--covariate-file strategy1/input_&quot;, mtd, &quot;/rosmap_pheno.ROSMAP_cov.ROSMAP_NIA_WGS.leftnorm.bcftools_qc.plink_qc.rosmap_proteomics.unrelated.plink_qc.prune.pca.Marchenko_PC.gz &quot;,
            &quot;--customized_cis_windows ROSMAP_pQTL_TADB_enhanced_cis.bed &quot;,
            &quot;--cwd strategy1/&quot;, mtd, &quot; &quot;,
            &quot;--container containers/tensorqtl.sif --MAC 5 --chromosome &quot;, i,
            &quot; -s build&quot;, 
            sep = &quot; &quot;
          )

        sbatch_script &lt;- paste(
            &quot;#!/bin/bash\n&quot;,
            &quot;#SBATCH --job-name=tensor_&quot;, mtd, i, &quot;\n&quot;,
            &quot;#SBATCH --mem=80G\n&quot;,
            &quot;#SBATCH --time=10:00:00\n&quot;,
            &quot;#SBATCH --output=tensor_%j.out\n&quot;,
            &quot;#SBATCH --error=tensor_%j.err\n&quot;,
            &quot;#SBATCH -p GEN\n\n&quot;,
            &quot;export PATH=
PATH\n&quot;,
            &quot;source ~/.bashrc\n&quot;,
            &quot;module load Singularity/3.9.4\n&quot;,
            &quot;cd ~\n\n&quot;,
            sos,
            sep = &quot;&quot;
        )

        writeLines(sbatch_script, con = file.path(&#39;strategy1/script_imp/&#39;, paste0(mtd, &quot;_tensor_&quot;, i, &quot;.sbatch&quot;)))
    }
}</code></pre>
<p>This step gives us 8 discovery sets for each sample size.</p>
</div>
<div id="calculate-the-replicate-rate" class="section level5">
<h5>Calculate the replicate rate</h5>
<p>For each of the discovery sets, we identify significant pairs as FDR
<span class="math inline">\(&lt; 0.05\)</span>, which gives us 8 sets of
significant pairs. Then, we calculate the proportion of significant
pairs that are still significant (FDR <span class="math inline">\(&lt;
0.05\)</span>) in the replication set. The formula for the replication
rate is:</p>
<p><span class="math display">\[ \text{Replication rate} =
\frac{\#\text{significant pairs in both discovery and replication
sets}}{\#\text{significant pairs in the discovery set}}\]</span></p>
<p>To calculate this replication rate, we first identify significant
pairs in standard set.</p>
<pre class="r"><code>standard.sum &lt;- list.files(path = &#39;strategy1/output/standard&#39;, pattern = &quot;rosmap_pheno.*.cis_qtl.regional.tsv.gz$&quot;, full.names = TRUE)

standard.lst &lt;- lapply(standard.sum, fread)
standard &lt;- rbindlist(standard.lst)

standard$id &lt;- paste0(standard$molecular_trait_id, &#39;-&#39;, standard$variant_id)
standard &lt;- standard %&gt;% group_by(molecular_trait_id) %&gt;% mutate(fdr = p.adjust(pvalue, method = &quot;fdr&quot;))
standard.sig &lt;- standard %&gt;% filter(fdr &lt; 0.05)</code></pre>
<p>Finally, we calculate singificant pairs in discovery sets and check
how many significant pairs in discoveries sets are still significant in
replication set.</p>
<pre class="r"><code>replication_rates &lt;- c()
for (mtd in c(&quot;ebmf&quot;, &quot;mofa&quot;, &quot;xgb&quot;, &quot;rf&quot;, &quot;soft&quot;, &quot;knn&quot;, &quot;mean&quot;, &quot;lod&quot;)) {
  imp.sum &lt;- list.files(path = paste0(&quot;strategy1/&quot;, mtd), pattern = paste0(&quot;rosmap_&quot;, mtd, &quot;.*.cis_qtl.regional.tsv.gz$&quot;), full.names = TRUE)
  imp.lst &lt;- lapply(imp.sum, fread)
  imp &lt;- rbindlist(imp.lst)
  
  imp &lt;- imp %&gt;% filter(molecular_trait_object_id %in% standard$molecular_trait_object_id)
  imp &lt;- imp %&gt;% group_by(molecular_trait_id) %&gt;% mutate(fdr = p.adjust(pvalue, method = &quot;fdr&quot;))
  imp$id &lt;- paste0(imp$molecular_trait_id, &#39;-&#39;, imp$variant_id)
  imp.sig &lt;- imp %&gt;% filter(fdr &lt; 0.05)
  
  pairs.sig &lt;- unique(imp.sig$id)
  replicated.pairs &lt;- noimp %&gt;% filter(id %in% pairs.sig)
  rate &lt;- mean(replicated.pairs$fdr &lt; 0.05)
  replication_rates &lt;- c(replication_rates, rate)
}</code></pre>
</div>
</div>
<div id="replication-analysis-on-strategy-b" class="section level3">
<h3>Replication Analysis on Strategy B</h3>
<p>In addition this strategy, we designed another way to evaluate
replication for each of 8 methods.</p>
<div id="extract-phenotypes-that-have-no-missing-samples"
class="section level5">
<h5>Extract Phenotypes that Have No Missing Samples</h5>
<pre class="r"><code>pheno.comp &lt;- pheno[complete.cases(pheno), ]</code></pre>
</div>
<div id="define-standard-set-1" class="section level5">
<h5>Define Standard Set</h5>
<p>The standard set is defined same as Strategy A.</p>
<pre class="r"><code>gene_list &lt;- c()
id_list &lt;- c()
chr_list &lt;- c()
for (i in 1:nrow(pheno)) {
  data_row &lt;- pheno[i, ]

  # Calculate number of exsiting samples
  num &lt;- sum(!is.na(data_row[, -c(1:4)]))

  # Create file name
  file_name &lt;- paste0(&#39;strategy2/input_per_gene/standard/rosmap_pheno.&#39;, data_row$ID, &#39;.bed&#39;)
  ensg_id &lt;- str_extract(data_row$ID, &quot;ENSG[0-9]+&quot;)

  # Write the row to a BED file if there are more than 350 exsiting samples
  if (length(data_row) &gt; 350) {
    write_bed(data_row, file_name)
    gene_list &lt;- c(gene_list, ensg_id)
    id_list &lt;- c(id_list, data_row$ID)
    chr_list &lt;- c(chr_list, data_row$chr)
  }
}</code></pre>
<p>Then, we run cis-QTL analysis on each protein with all exsting
samples by using <a
href="https://github.com/StatFunGen/xqtl-protocol">FunGen-xQTL
Computational Protocol</a>.</p>
<pre class="r"><code>for (i in length(gene_lst)) {
    sos_command &lt;- paste0(
        &quot;sos run xqtl-protocol/pipeline/TensorQTL.ipynb cis:1  &quot;,
        &quot;--genotype-file ROSMAP_NIA_WGS.leftnorm.bcftools_qc.plink_qc.&quot;, gene_list[i], &quot;.bed &quot;,
        &quot;--phenotype-file strategy2/input_per_gene/standard/rosmap_pheno.&quot;, id_list[i], &quot;.bed.gz &quot;,
        &quot;--covariate-file cov/soft/rosmap_soft.resid.Marchenko_PC.gz &quot;,
        &quot;--customized_cis_windows ROSMAP_pQTL_TADB_enhanced_cis.bed &quot;,
        &quot;--cwd strategy2/output/standard &quot;,
        &quot;--container containers/tensorqtl.sif --MAC 5 --chromosome &quot;, chr_list[i],
        &quot; -s build&quot;, 
        sep = &quot; &quot;
      )

    sbatch_script &lt;- paste(
        &quot;#!/bin/bash\n&quot;,
        &quot;#SBATCH --job-name=tensor_&quot;, gene_list[i], &quot;\n&quot;,
        &quot;#SBATCH --mem=30G\n&quot;,
        &quot;#SBATCH --time=10:00:00\n&quot;,
        &quot;#SBATCH --output=output/tensor_%j.out\n&quot;,
        &quot;#SBATCH --error=output/tensor_%j.err\n&quot;,
        &quot;#SBATCH -p CSG\n\n&quot;,
        &quot;export PATH=
PATH\n&quot;,
        &quot;source ~/.bashrc\n&quot;,
        &quot;module load Singularity/3.9.4\n&quot;,
        &quot;cd ~\n\n&quot;,
        sos_command,
        sep = &quot;&quot;
    )
    
    writeLines(sbatch_script, con = file.path(&#39;strategy2/script/&#39;, paste0(&quot;tensor_&quot;, id_list[i], &quot;.sbatch&quot;)))
}</code></pre>
<p>The result from this step is considered as replication set.</p>
</div>
<div id="define-imputed-set-1" class="section level5">
<h5>Define Imputed Set</h5>
<p>We randomly assign N = 50, 100, 150 missing samples for each
protein.</p>
<pre class="r"><code>n_miss &lt;- 50, 100, 150

for (i in nrow(pheno.comp)) {
    # Randomly select missing
    missing_samples &lt;- sample(colnames(pheno.comp)[-c(1:4)], n_miss)
    # Set these to NA
    pheno_miss[i, missing_samples] &lt;- NA
}</code></pre>
<p>We then imputed the proteomics data first by using each method. Refer
to Section
<code>Impute Dataset with Generated Missing by Using Different Methods</code>
in <a
href="https://zq2209.github.io/omics-imputation-paper/imputation_accuracy_benchmark.html">imputation
accuracy benchmark</a> for details on how to impute missing data. The
output of imputation is
<code>rosmap_pheno_{method}_imp.bed.gz</code>.</p>
<pre class="r"><code>n_miss &lt;- 50, 100, 150
n &lt;- 350
sample_lst &lt;- colnames(pheno.miss[, 5:ncol(pheno.miss)])
sample.all &lt;- list()
for (i in 1:nrow(pheno.miss)) {
    row &lt;- pheno[i, 5:ncol(pheno)]
    #id &lt;- pheno[i, 1:4]
    # randomly select non-missing samples
    non_missing_samples &lt;- sample_lst[!as.vector(is.na(row))]   
    non_missing &lt;- sample(non_missing_samples, size = n - n_miss, replace = FALSE)
    # missing samples
    missing &lt;- sample_lst[as.vector(is.na(row))]
    samples &lt;- c(non_missing, missing)
    sample.all[[i]] &lt;- samples
}</code></pre>
<p>The imputed phenotype for QTL analysis includes number of imputed
samples (i.e. n_miss = 50, 100, 150) plus randomly selected 350-n_miss
samples from the existing samples.</p>
<pre class="r"><code>for (mtd in c(&quot;ebmf&quot;, &quot;mofa&quot;, &quot;xgb&quot;, &quot;rf&quot;, &quot;soft&quot;, &quot;knn&quot;, &quot;mean&quot;, &quot;lod&quot;)) {
    pheno.imp &lt;- read_delim(paste0(&#39;strategy2/rosmap_pheno_&#39;, mtd, &#39;_imp.bed.gz&#39;))
    
    for (i in 1:nrow(pheno.imp)) {
    # Get the list of samples for the current row
        samples &lt;- sample.all[[i]]
        # Select the values from the dataframe for the current row based on sample names
        id &lt;- pheno.imp[i, 1:4]
        selected_values &lt;- pheno.imp[i, samples, drop = FALSE]
        data_df &lt;- cbind(id, selected_values)
        # Save the new row dataframe as a BED file
        file_name &lt;- paste0(&#39;strategy2/&#39;, mtd, &#39;/rosmap_&#39;, mtd, &#39;.&#39;, data_df$ID, &#39;.bed&#39;)
        write_bed(data_df, file_name)
    }
}</code></pre>
<p>Before running cis-QTL analysis for each method, we identify hidden
factors and calculate residuals first.</p>
<pre class="r"><code>for (mtd in c(&quot;ebmf&quot;, &quot;mofa&quot;, &quot;xgb&quot;, &quot;rf&quot;, &quot;soft&quot;, &quot;knn&quot;, &quot;mean&quot;, &quot;lod&quot;)) {
    hidden_sos &lt;- paste0(
        &quot;sos run xqtl-protocol/pipeline/covariate_hidden_factor.ipynb Marchenko_PC  &quot;,
        &quot;--phenoFile strategy2/rosmap_pheno.&quot;, mtd, &quot;_imp.bed.gz &quot;,
        &quot;--covFile cov/ROSMAP_cov.ROSMAP_NIA_WGS.leftnorm.bcftools_qc.plink_qc.rosmap_proteomics.unrelated.plink_qc.prune.pca.gz &quot;,
        &quot;--cwd strategy2/input_&quot;, mtd, &quot; &quot;,
        &quot;--container containers/pcatools.sif -J 50&quot;,
        sep = &quot; &quot;
    )
    
    sbatch_script &lt;- paste(
        &quot;#!/bin/bash\n&quot;,
        &quot;#SBATCH --job-name=hidden_&quot;, mtd, &quot;\n&quot;,
        &quot;#SBATCH --mem=30G\n&quot;,
        &quot;#SBATCH --time=10:00:00\n&quot;,
        &quot;#SBATCH --output=/hidden_%j.out\n&quot;,
        &quot;#SBATCH --error=/hidden_%j.err\n&quot;,
        &quot;#SBATCH -p CSG\n\n&quot;,
        &quot;export PATH=
PATH\n&quot;,
        &quot;source ~/.bashrc\n&quot;,
        &quot;module load Singularity/3.9.4\n&quot;,
        &quot;cd ~\n\n&quot;,
        hidden_sos,
        sep = &quot;&quot;
    )
    
    writeLines(sbatch_script, con = file.path(&#39;strategy2/script_imp/&#39;, paste0(&quot;hidden_&quot;, mtd, &quot;.sbatch&quot;)))
}</code></pre>
<p>Next step is to run cis-QTL analysis for each method.</p>
<pre class="r"><code>for (mtd in c(&quot;ebmf&quot;, &quot;mofa&quot;, &quot;xgb&quot;, &quot;rf&quot;, &quot;soft&quot;, &quot;knn&quot;, &quot;mean&quot;, &quot;lod&quot;)) {
    for (i in length(gene_lst)) {
        sos &lt;- paste0(
            &quot;sos run xqtl-protocol/pipeline/TensorQTL.ipynb cis:1  &quot;,
            &quot;--genotype-file ROSMAP_NIA_WGS.leftnorm.bcftools_qc.plink_qc.&quot;, gene_list[i], &quot;.bed &quot;,
            &quot;--phenotype-file strategy2/input_per_gene/&quot;, mtd, &#39;/rosmap_pheno.&#39;, data_row$ID, &quot;.bed.gz &quot;,
            &quot;--covariate-file strategy2/input_&quot;, mtd, &quot;/rosmap_pheno.ROSMAP_cov.ROSMAP_NIA_WGS.leftnorm.bcftools_qc.plink_qc.rosmap_proteomics.unrelated.plink_qc.prune.pca.Marchenko_PC.gz &quot;,
            &quot;--customized_cis_windows ROSMAP_pQTL_TADB_enhanced_cis.bed &quot;,
            &quot;--cwd strategy2/&quot;, mtd, &quot; &quot;,
            &quot;--container containers/tensorqtl.sif --MAC 5 --chromosome &quot;, i,
            &quot; -s build&quot;, 
            sep = &quot; &quot;
          )

        sbatch_script &lt;- paste(
            &quot;#!/bin/bash\n&quot;,
            &quot;#SBATCH --job-name=tensor_&quot;, mtd, i, &quot;\n&quot;,
            &quot;#SBATCH --mem=80G\n&quot;,
            &quot;#SBATCH --time=10:00:00\n&quot;,
            &quot;#SBATCH --output=tensor_%j.out\n&quot;,
            &quot;#SBATCH --error=tensor_%j.err\n&quot;,
            &quot;#SBATCH -p GEN\n\n&quot;,
            &quot;export PATH=
PATH\n&quot;,
            &quot;source ~/.bashrc\n&quot;,
            &quot;module load Singularity/3.9.4\n&quot;,
            &quot;cd ~\n\n&quot;,
            sos,
            sep = &quot;&quot;
        )

        writeLines(sbatch_script, con = file.path(&#39;strategy1/script_imp/&#39;, paste0(mtd, &quot;_tensor_&quot;, i, &quot;.sbatch&quot;)))
    }
}</code></pre>
<p>This step gives us 8 discovery sets for each number of missing
assignment.</p>
</div>
<div id="calculate-the-replicate-rate-1" class="section level5">
<h5>Calculate the replicate rate</h5>
<p>Similar to the previous strategy, we calculate the replication rate
by using the same formula.</p>
<p>To calculate this replication rate, we first identify significant
pairs in standard set.</p>
<pre class="r"><code>standard.sum &lt;- list.files(path = &#39;strategy2/output/standard&#39;, pattern = &quot;rosmap_pheno.*.cis_qtl.regional.tsv.gz$&quot;, full.names = TRUE)

standard.lst &lt;- lapply(standard.sum, fread)
standard &lt;- rbindlist(standard.lst)

standard$id &lt;- paste0(standard$molecular_trait_id, &#39;-&#39;, standard$variant_id)
standard &lt;- standard %&gt;% group_by(molecular_trait_id) %&gt;% mutate(fdr = p.adjust(pvalue, method = &quot;fdr&quot;))
standard.sig &lt;- standard %&gt;% filter(fdr &lt; 0.05)</code></pre>
<p>Finally, we calculate singificant pairs in discovery sets and check
how many significant pairs in discoveries sets are still significant in
replication set.</p>
<pre class="r"><code>replication_rates &lt;- c()
for (mtd in c(&quot;ebmf&quot;, &quot;mofa&quot;, &quot;xgb&quot;, &quot;rf&quot;, &quot;soft&quot;, &quot;knn&quot;, &quot;mean&quot;, &quot;lod&quot;)) {
  imp.sum &lt;- list.files(path = paste0(&quot;strategy2/&quot;, mtd), pattern = paste0(&quot;rosmap_&quot;, mtd, &quot;.*.cis_qtl.regional.tsv.gz$&quot;), full.names = TRUE)
  imp.lst &lt;- lapply(imp.sum, fread)
  imp &lt;- rbindlist(imp.lst)
  
  imp &lt;- imp %&gt;% filter(molecular_trait_object_id %in% standard$molecular_trait_object_id)
  imp &lt;- imp %&gt;% group_by(molecular_trait_id) %&gt;% mutate(fdr = p.adjust(pvalue, method = &quot;fdr&quot;))
  imp$id &lt;- paste0(imp$molecular_trait_id, &#39;-&#39;, imp$variant_id)
  imp.sig &lt;- imp %&gt;% filter(fdr &lt; 0.05)
  
  pairs.sig &lt;- unique(imp.sig$id)
  replicated.pairs &lt;- noimp %&gt;% filter(id %in% pairs.sig)
  rate &lt;- mean(replicated.pairs$fdr &lt; 0.05)
  replication_rates &lt;- c(replication_rates, rate)
}</code></pre>
</div>
</div>
<div id="visualization-of-replication-results" class="section level3">
<h3>Visualization of Replication Results</h3>
<pre class="r"><code># Define the methods and values
methods &lt;- c(&#39;gEBMF&#39;, &#39;MOFA2&#39;, &quot;SoftImpute&quot;, &quot;MissXGB&quot;, &#39;MissForest&#39;, &quot;KNN&quot;, &quot;MeanImpute&quot;, &#39;LOD&#39;)

data1 &lt;- data.frame(
  Method = factor(rep(methods, times = 3), levels = methods),
  Value = c(replication_rates_s1_200, replication_rates_s1_250, replication_rates_s1_300),
  Sample = factor(rep(c(&quot;200&quot;, &quot;250&quot;, &quot;300&quot;), each = length(methods)))
)


data2 &lt;- data.frame(
  Method = factor(rep(methods, times = 3), levels = methods),
  Value = c(replication_rates_s1_50, replication_rates_s1_100, replication_rates_s1_150),
  Missing = factor(rep(c(&quot;50&quot;, &quot;100&quot;, &quot;150&quot;), each = length(methods)), levels = c(&#39;50&#39;, &#39;100&#39;, &#39;150&#39;))
)

rep_1 &lt;- ggplot(data1, aes(Method, Value, fill = Sample)) +
  geom_bar(stat=&quot;identity&quot;, position = &quot;dodge&quot;) + 
  labs(title = &quot;Replication&quot;,
       x = &quot;Method&quot;,
       y = &quot;Replication Rate&quot;) +
  theme_minimal() +
  coord_cartesian(ylim =c (0.6, 1)) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

rep_2 &lt;- ggplot(data2, aes(Method, Value, fill = Missing)) +
  geom_bar(stat=&quot;identity&quot;, position = &quot;dodge&quot;) + 
  labs(title = &quot;Replication&quot;,
       x = &quot;Method&quot;,
       y = &quot;Replication Rate&quot;) +
  theme_minimal() +
  coord_cartesian(ylim =c (0.6, 1)) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

combined_plot &lt;- (rep_1 | rep_2) 
print(combined_plot)</code></pre>
</div>
<div id="example-output" class="section level3">
<h3>Example Output</h3>
<p><img src="figure/replication.png" style="width:60.0%" /></p>
<br>
<p>
<button type="button" class="btn btn-default btn-workflowr btn-workflowr-sessioninfo" data-toggle="collapse" data-target="#workflowr-sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-wrench" aria-hidden="true"></span>
Session information
</button>
</p>
<div id="workflowr-sessioninfo" class="collapse">
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>R version 4.4.3 (2025-02-28)
Platform: aarch64-apple-darwin20
Running under: macOS Sequoia 15.4

Matrix products: default
BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib 
LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

time zone: America/Chicago
tzcode source: internal

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

loaded via a namespace (and not attached):
 [1] vctrs_0.6.5       cli_3.6.4         knitr_1.50        rlang_1.1.5      
 [5] xfun_0.51         stringi_1.8.7     promises_1.3.2    jsonlite_2.0.0   
 [9] workflowr_1.7.1   glue_1.8.0        rprojroot_2.0.4   git2r_0.36.2     
[13] htmltools_0.5.8.1 httpuv_1.6.15     sass_0.4.9        rmarkdown_2.29   
[17] evaluate_1.0.3    jquerylib_0.1.4   tibble_3.2.1      fastmap_1.2.0    
[21] yaml_2.3.10       lifecycle_1.0.4   whisker_0.4.1     stringr_1.5.1    
[25] compiler_4.4.3    fs_1.6.5          Rcpp_1.0.14       pkgconfig_2.0.3  
[29] rstudioapi_0.17.1 later_1.4.1       digest_0.6.37     R6_2.6.1         
[33] pillar_1.10.1     magrittr_2.0.3    bslib_0.9.0       tools_4.4.3      
[37] cachem_1.1.0     </code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>


<!-- Adjust MathJax settings so that all math formulae are shown using
TeX fonts only; see
https://docs.mathjax.org/en/latest/web/configuration.html. This will make
the presentation more consistent at the cost of the webpage sometimes
taking slightly longer to load. Note that this only works because the
footer is added to webpages before the MathJax javascript. -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>





</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
